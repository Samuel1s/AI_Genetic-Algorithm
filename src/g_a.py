#***********************************************************************************
#*                           Algoritmo Genético                                    *
#*---------------------------------------------------------------------------------*
#* @AUTHOR: Samuel Filipe dos Santos                                               *
#* @TEACHER: Rogério Martins Gomes.                                                *
#* @LANGUAGE: Python                                                               *
#* @DISCIPLINE: Inteligência Artificial                                            *
#* @CODING: UTF-8                                                                  *
#* @DATE: 19 de março de 2021                                                      *
#***********************************************************************************

#***********************************************************************************
#*                       Parâmetros Genéticos Selecionados                         *
#*----------------------------------------|----------------------------------------*
#*Tamanho da população                    |                          25 indivíduos *
#*Tipo de crossover                       |                          Aritmético    * 
#*Número de gerações                      |                          500           *
#*Taxa de crossover                       |                          0.75          *
#*Taxa de mutação                         |                          0.1           *
#*Função objetivo e fitness               |                          --> f(x,y)    * 
#*Forma de seleção                        |                          Roleta        *
#*----------------------------------------|----------------------------------------*
#*  f(x, y) = sin(x)e^((1−cos(𝑦))^2) + cos(𝑦)e^((1−sin(x))^2) + (x − y)^2          *
#***********************************************************************************

#***********************************************************************************
#*                       Algumas Observações importantes                           *
#*---------------------------------------------------------------------------------*
#* Para a plotagem dos gráficos deve ser instalado o matplotlib.                   *
#* No terminal: pip install matplotlib                                             *
#*                                                                                 *
#* O problema em questão é de minimização porém como o valor MIN é negativo esse   *
#* foi tranformado para um problema de maximização multiplicando por -1 e seu grá- *
#* fico foi transladado para acima do eixo Y somando com o novo valor MIN (152).   *
#*                                                                                 *
#* Automatically generated by Colaboratory.                                        *
#*                                                                                 *
#* Original file is located at                                                     *
#*    https://colab.research.google.com/drive/1dy3icIfuDDKzdlWaENCi0E7xMfnSZqWb    *
#*                                                                                 *
#***********************************************************************************


import math
import random
import matplotlib.pyplot as plot
import numpy as np

MAX_GENERATIONS = 500
POPULATION_SIZE = 25

CROSSOVER_RATE = 0.75
MUTATION_RATE = 0.015

MAX_VALUE = 106.7645
MIN_VALUE = 152.0000


def bird_function(x, y):
    return np.sin(x) * np.exp((1 - np.cos(y)) ** 2) + np.cos(y) * np.exp((1 - np.sin(x)) ** 2) + (x - y) ** 2

def plot_function(arr, color):
    for a in arr:
        plot.plot(a[0], a[1], color)
   
def objective(x, y):
    return MIN_VALUE - ( math.sin(x) * math.exp((1 - math.cos(y)) ** 2) + math.cos(y) * math.exp((1 - math.sin(x)) ** 2) + (x - y) ** 2 )

def fitness(a):
    return objective(a[0], a[1])

def select(P):
    F = [ fitness(a) for a in P ]
    N = [ z / sum(F) for z in F ]
    R = [] # Roulette.

    for i, n in enumerate(N):
        base = 0

        for j in range(i):
            base += N[i]

        R.append(base + n)

    chosen = random.uniform(0, R[len(R) - 1])

    for i, n in enumerate(R):
        if n >= chosen:
            return P[i]

def crossover(a, b):
    chance = random.random()

    if chance <= CROSSOVER_RATE:
        Ca = (0.3 * a[0] + 0.7 * b[0], 0.3 * a[1] + 0.7 * b[1])
        Cb = (0.7 * a[0] + 0.3 * b[0], 0.7 * a[1] + 0.3 * b[1])

        return Ca, Cb

    return a, b

def mutate(a):
    chance_x = random.random()
    chance_y = random.random()

    x = random.uniform(-10, 10) if chance_x <= MUTATION_RATE else a[0]
    y = random.uniform(-10, 10) if chance_y <= MUTATION_RATE else a[1]

    return x, y

def match(a):
    return a and fitness(a) == (MAX_VALUE + MIN_VALUE)

def main():
    P, Best, Worse, Gen = [], None, None, 0
    b_dist, w_dist, a_dist = [], [], []
    c_betters, c_worses = [], []

    for i in range(POPULATION_SIZE):
        x = random.uniform(-10, 10)
        y = random.uniform(-10, 10)

        P.append((x, y))

    while Gen < MAX_GENERATIONS and not match(Best):
        Q, Total = [], 0
    
        for a in P:
            f = fitness(a)
            Total += f

            if not Best or f > fitness(Best):
                Best = a
                c_betters.append(a)

            if not Worse or f < fitness(Worse):
                Worse = a
                c_worses.append(a)

        for _ in range(POPULATION_SIZE // 2):
            Pa = select(P)
            Pb = select(P)

            Ca, Cb = crossover(Pa, Pb)

            Q.append(mutate(Ca))
            Q.append(mutate(Cb))

        b_dist.append(fitness(Best))
        w_dist.append(fitness(Worse))
        a_dist.append(Total / len(P))
  
        P = Q
        Gen += 1

    print('MELHORES VALORES ENCONTRADOS:')
    for x in c_betters:
        print('[ (X, Y) =', x[0], ',', x[1], ']')
    print('-------------------------------------------------------')
    print('')
    print('MELHOR VALOR ENCONTRADO:')
    print('[ X =', Best[0], ']')
    print('[ Y =', Best[1], ']')
    print('[ Z =', -(fitness(Best) - MIN_VALUE), ']')
    print('-------------------------------------------------------')
    print('')
    
    print('PIORES VALORES ENCONTRADOS:')
    for x in c_worses:
        print('[ (X, Y) =', x[0], ',', x[1], ']')
    print('-------------------------------------------------------')
    print('')
    print('PIOR VALOR ENCONTRADO:')
    print('[ X =', Worse[0], ']')
    print('[ Y =', Worse[1], ']')
    print('[ Z =', -(fitness(Worse) - MAX_VALUE), ']')
    print('-------------------------------------------------------')
    print('')

    g_dist = range(MAX_GENERATIONS)
    
    plot.figure(figsize=(10, 7))
    plot.subplot(2, 1, 1)
    plot.plot(g_dist, b_dist, 'b', label='Best')
    plot.plot(g_dist, w_dist, 'r', label='Worse')
    plot.plot(g_dist, a_dist, 'g', label='Average')
    plot.ylabel('values')
    plot.title('Gerações x Valores')
    plot.legend(bbox_to_anchor=(0.95,0.5), loc="lower right",  borderaxespad=0.)

    plot.subplot(2, 1, 2)
    x = np.linspace(-10, 10, MAX_GENERATIONS)
    y = np.linspace(-10, 10, MAX_GENERATIONS)
    X, Y = np.meshgrid(x, y)
    Z = bird_function(X, Y)
    
    plot.contour(X,Y,Z)
    plot.xlabel('generations')
    plot.ylabel('values')
    plot.title('Curva Nível - Piores e Melhores Valores')
    plot_function(c_betters, 'bo')
    plot_function(c_worses, 'ro')   
    plot.plot(Best[0], Best[1], 'go') 
   
    plot.show()

   

main()